<!doctype html>
<html lang="zh-cn">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Golang Study</title>
</head>
<body>

 <ol>
<li>将一个字符串反转，例如 &ldquo;hello world&rdquo; 变成 &ldquo;dlrow olleh&rdquo;</li>
</ol>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

func main() {
	s := &quot;hello world&quot;
	r := []rune(s)
	for i, j := 0, len(r)-1; i &lt; j; i, j = i+1, j-1 {
		r[i], r[j] = r[j], r[i]
	}
	fmt.Println(string(r))
}
</code></pre>

<ol>
<li>查找一个slice中最大和最小的元素并返回它们的索引</li>
</ol>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

func findMaxAndMin(s []int) (maxIndex, minIndex int) {
	maxIndex, minIndex = 0, 0
	for i := 0; i &lt; len(s); i++ {
		if s[i] &gt; s[maxIndex] {
			maxIndex = i
		}
		if s[i] &lt; s[minIndex] {
			minIndex = i
		}
	}
	return
}

func main() {
	s := []int{4, 6, 2, 8, 1, 7, 9}
	maxIndex, minIndex := findMaxAndMin(s)
	fmt.Printf(&quot;max index=%d, value=%d\n&quot;, maxIndex, s[maxIndex])
	fmt.Printf(&quot;min index=%d, value=%d\n&quot;, minIndex, s[minIndex])
}
</code></pre>

<ol>
<li>实现一个函数，用二分查找法查找一个元素是否在一个已排序的slice中</li>
</ol>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

func binarySearch(s []int, target int) int {
	left, right := 0, len(s)-1
	for left &lt;= right {
		mid := left + (right-left)/2
		if s[mid] == target {
			return mid
		} else if s[mid] &lt; target {
			left = mid + 1
		} else {
			right = mid - 1
		}
	}
	return -1
}

func main() {
	s := []int{1, 2, 4, 6, 7, 8, 9}
	target := 4
	index := binarySearch(s, target)
	if index == -1 {
		fmt.Printf(&quot;%d not found\n&quot;, target)
	} else {
		fmt.Printf(&quot;%d found at index %d\n&quot;, target, index)
	}
}
</code></pre>

<ol>
<li>实现一个函数，用冒泡排序将一个slice从小到大排序</li>
</ol>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

func bubbleSort(s []int) {
	for i := 0; i &lt; len(s); i++ {
		for j := i + 1; j &lt; len(s); j++ {
			if s[i] &gt; s[j] {
				s[i], s[j] = s[j], s[i]
			}
		}
	}
}

func main() {
	s := []int{4, 6, 2, 8, 1, 7, 9}
	fmt.Println(&quot;before sorting:&quot;, s)
	bubbleSort(s)
	fmt.Println(&quot;after sorting:&quot;, s)
}
</code></pre>

<ol>
<li>实现一个生成斐波那契数列的函数</li>
</ol>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

func fibonacci(n int) []int {
	if n &lt;= 1 {
		return []int{n}
	}
	fib := []int{0, 1}
	for i := 2; i &lt; n; i++ {
		fib = append(fib, fib[i-1]+fib[i-2])
	}
	return fib
}

func main() {
	fmt.Println(fibonacci(10))
}
</code></pre>
 </body>
</html>