<!doctype html>
<html lang="zh-cn">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Golang Study</title>
</head>
<body>

 <ol>
<li><p>写一个函数，计算两个数的和并返回结果。</p>

<pre><code>func add(x, y int) int {
return x + y
}
</code></pre></li>

<li><p>写一个函数，计算一个列表中所有偶数的和并返回结果。</p>

<pre><code>func sumEven(nums []int) int {
sum := 0
for _, num := range nums {
    if num % 2 == 0 {
        sum += num
    }
}
return sum
}
</code></pre></li>

<li><p>写一个函数，判断一个字符串是否为回文字符串。</p>

<pre><code>func isPalindrome(str string) bool {
for i := 0; i &lt; len(str) / 2; i++ {
    if str[i] != str[len(str)-i-1] {
        return false
    }
}
return true
}
</code></pre></li>

<li><p>实现一个简单的堆栈。</p>

<pre><code>type Stack struct {
values []interface{}
}
func (s *Stack) Push(value interface{}) {
s.values = append(s.values, value)
}
func (s *Stack) Pop() interface{} {
if len(s.values) == 0 {
    return nil
}
value := s.values[len(s.values)-1]
s.values = s.values[:len(s.values)-1]
return value
}
func (s *Stack) Peek() interface{} {
if len(s.values) == 0 {
    return nil
}
return s.values[len(s.values)-1]
}
func (s *Stack) Size() int {
return len(s.values)
}
</code></pre></li>

<li><p>实现一个简单的链表结构。</p>

<pre><code>type Node struct {
data interface{}
next *Node
}
type LinkedList struct {
head *Node
tail *Node
}
func (l *LinkedList) Add(value interface{}) {
newNode := &amp;Node{data: value}
if l.head == nil {
    l.head = newNode
    l.tail = newNode
} else {
    l.tail.next = newNode
    l.tail = newNode
}
}
func (l *LinkedList) Remove(value interface{}) {
if l.head == nil {
    return
}
if l.head.data == value {
    l.head = l.head.next
    return
}
currentNode := l.head
for currentNode.next != nil {
    if currentNode.next.data == value {
        currentNode.next = currentNode.next.next
        if currentNode.next == nil {
            l.tail = currentNode
        }
        return
    }
    currentNode = currentNode.next
}
}
func (l *LinkedList) Traverse() {
currentNode := l.head
for currentNode != nil {
    fmt.Print(currentNode.data, &quot; &quot;)
    currentNode = currentNode.next
}
fmt.Println()
}
</code></pre></li>
</ol>
 </body>
</html>