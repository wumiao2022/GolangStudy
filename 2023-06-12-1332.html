<!doctype html>
<html lang="zh-cn">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Golang Study</title>
</head>
<body>

 <p>以下是每日多练的练习实例代码：</p>

<ol>
<li><p>翻转字符串</p>

<pre><code>func reverseString(str string) string {
runes := []rune(str)
for i, j := 0, len(runes)-1; i &lt; j; i, j = i+1, j-1 {
    runes[i], runes[j] = runes[j], runes[i]
}
return string(runes)
}
</code></pre></li>

<li><p>斐波那契数列</p>

<pre><code>func fibonacci(n int) int {
if n &lt;= 1 {
    return n
}
return fibonacci(n-1) + fibonacci(n-2)
}
</code></pre></li>

<li><p>判断一个数是否是质数</p>

<pre><code>func isPrime(n int) bool {
if n &lt;= 1 {
    return false
}
for i := 2; i &lt;= int(math.Sqrt(float64(n))); i++ {
    if n%i == 0 {
        return false
    }
}
return true
}
</code></pre></li>

<li><p>寻找两个有序数组的中位数</p>

<pre><code>func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
m, n := len(nums1), len(nums2)
if m &gt; n {
    nums1, nums2, m, n = nums2, nums1, n, m
}
iMin, iMax, halfLen := 0, m, (m+n+1)/2
for iMin &lt;= iMax {
    i := (iMin + iMax) / 2
    j := halfLen - i
    if i &lt; m &amp;&amp; nums2[j-1] &gt; nums1[i] {
        iMin = i + 1
    } else if i &gt; 0 &amp;&amp; nums1[i-1] &gt; nums2[j] {
        iMax = i - 1
    } else {
        maxLeft := 0
        if i == 0 {
            maxLeft = nums2[j-1]
        } else if j == 0 {
            maxLeft = nums1[i-1]
        } else {
            maxLeft = int(math.Max(float64(nums1[i-1]), float64(nums2[j-1])))
        }
        if (m+n)%2 == 1 {
            return float64(maxLeft)
        }
        minRight := 0
        if i == m {
            minRight = nums2[j]
        } else if j == n {
            minRight = nums1[i]
        } else {
            minRight = int(math.Min(float64(nums1[i]), float64(nums2[j])))
        }
        return float64(maxLeft+minRight) / 2.0
    }
}
return 0
}
</code></pre></li>

<li><p>二叉树的最大深度</p>

<pre><code>type TreeNode struct {
Val   int
Left  *TreeNode
Right *TreeNode
}
func maxDepth(root *TreeNode) int {
if root == nil {
    return 0
}
left := maxDepth(root.Left)
right := maxDepth(root.Right)
return int(math.Max(float64(left), float64(right))) + 1
}
</code></pre></li>
</ol>
 </body>
</html>