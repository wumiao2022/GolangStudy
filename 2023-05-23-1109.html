<!doctype html>
<html lang="zh-cn">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Golang Study</title>
</head>
<body>

 <ol>
<li>实现一个简单的Web服务，返回“Hello World！”的字符串。
&ldquo;`go
package main</li>
</ol>

<p>import (
	&ldquo;fmt&rdquo;
	&ldquo;net/http&rdquo;
)</p>

<p>func helloWorld(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &ldquo;Hello World!&rdquo;)
}</p>

<p>func main() {
	http.HandleFunc(&ldquo;/&rdquo;, helloWorld)
	http.ListenAndServe(&ldquo;:8080&rdquo;, nil)
}</p>

<pre><code>
2. 对切片进行排序并打印结果。
```go
package main

import (
	&quot;fmt&quot;
	&quot;sort&quot;
)

func main() {
	nums := []int{8, 5, 3, 7, 2, 9, 1, 4, 6}
	sort.Ints(nums)
	fmt.Println(nums)
}
</code></pre>

<ol>
<li>实现一个空接口数组的遍历和类型断言。
&ldquo;`go
package main</li>
</ol>

<p>import (
	&ldquo;fmt&rdquo;
)</p>

<p>func main() {
	arr := []interface{}{3, &ldquo;hello&rdquo;, 1.23, true}
	for _, v := range arr {
		switch v.(type) {
		case int:
			fmt.Println(&ldquo;This is an integer:&rdquo;, v.(int))
		case string:
			fmt.Println(&ldquo;This is a string:&rdquo;, v.(string))
		case float64:
			fmt.Println(&ldquo;This is a float:&rdquo;, v.(float64))
		case bool:
			fmt.Println(&ldquo;This is a boolean:&rdquo;, v.(bool))
		default:
			fmt.Println(&ldquo;Unhandled type&rdquo;)
		}
	}
}</p>

<pre><code>
4. 实现一个函数，接受一个整数参数，并返回一个匿名函数，该匿名函数接受一个整数参数并返回一个整数，该整数为传入的整数与最初传入的整数相加的结果。
```go
package main

import (
	&quot;fmt&quot;
)

func add(num int) func(int) int {
	return func(x int) int {
		return num + x
	}
}

func main() {
	add2 := add(2)
	fmt.Println(add2(3))
}
</code></pre>

<ol>
<li>实现一个程序，统计一个文本文件中每个单词出现的次数，并将结果打印到控制台。
&ldquo;`go
package main</li>
</ol>

<p>import (
	&ldquo;bufio&rdquo;
	&ldquo;fmt&rdquo;
	&ldquo;os&rdquo;
	&ldquo;strings&rdquo;
)</p>

<p>func main() {
	file, err := os.Open(&ldquo;words.txt&rdquo;)
	if err != nil {
		panic(err)
	}
	defer file.Close()</p>

<pre><code>scanner := bufio.NewScanner(file)
scanner.Split(bufio.ScanWords)

wordCount := make(map[string]int)

for scanner.Scan() {
	word := strings.ToLower(scanner.Text())
	wordCount[word]++
}

if err := scanner.Err(); err != nil {
	panic(err)
}

for k, v := range wordCount {
	fmt.Printf(&quot;%s: %d\n&quot;, k, v)
}
</code></pre>

<p>}
&ldquo;`</p>
 </body>
</html>