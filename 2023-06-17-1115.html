<!doctype html>
<html lang="zh-cn">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Golang Study</title>
</head>
<body>

 <p>以下为每日练习题代码，供参考：</p>

<p><strong>Day 1</strong></p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    // 1. 输出Hello, World!
    fmt.Println(&quot;Hello, World!&quot;)
    
    // 2. 输出1到10的数字
    for i := 1; i &lt;= 10; i++ {
        fmt.Print(i, &quot; &quot;)
    }
    fmt.Println()
    
    // 3. 输出10到1的数字
    for i := 10; i &gt;= 1; i-- {
        fmt.Print(i, &quot; &quot;)
    }
    fmt.Println()
    
    // 4. 输出1到10中的偶数
    for i := 1; i &lt;= 10; i++ {
        if i % 2 == 0 {
            fmt.Print(i, &quot; &quot;)
        }
    }
    fmt.Println()
    
    // 5. 计算1到100的和
    sum := 0
    for i := 1; i &lt;= 100; i++ {
        sum += i
    }
    fmt.Println(&quot;The sum is&quot;, sum)
}
</code></pre>

<p><strong>Day 2</strong></p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    // 1. 计算1到100中的奇数和
    sum := 0
    for i := 1; i &lt;= 100; i++ {
        if i % 2 == 1 {
            sum += i
        }
    }
    fmt.Println(&quot;The sum of odd numbers is&quot;, sum)
    
    // 2. 打印九九乘法表
    for i := 1; i &lt;= 9; i++ {
        for j := 1; j &lt;= i; j++ {
            fmt.Printf(&quot;%d*%d=%d &quot;, j, i, i*j)
        }
        fmt.Println()
    }
    
    // 3. 判断一个数是否是素数
    num := 17
    isPrime := true
    for i := 2; i &lt; num; i++ {
        if num % i == 0 {
            isPrime = false
            break
        }
    }
    if isPrime {
        fmt.Printf(&quot;%d is a prime number\n&quot;, num)
    } else {
        fmt.Printf(&quot;%d is not a prime number\n&quot;, num)
    }
    
    // 4. 找出100以内的所有素数
    for i := 2; i &lt;= 100; i++ {
        isPrime := true
        for j := 2; j &lt; i; j++ {
            if i % j == 0 {
                isPrime = false
                break
            }
        }
        if isPrime {
            fmt.Print(i, &quot; &quot;)
        }
    }
    fmt.Println()
    
    // 5. 输出斐波那契数列的前20项
    a, b := 0, 1
    for i := 0; i &lt; 20; i++ {
        fmt.Print(a, &quot; &quot;)
        a, b = b, a+b
    }
    fmt.Println()
}
</code></pre>

<p><strong>Day 3</strong></p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    // 1. 计算1到100中的偶数和
    sum := 0
    for i := 1; i &lt;= 100; i++ {
        if i % 2 == 0 {
            sum += i
        }
    }
    fmt.Println(&quot;The sum of even numbers is&quot;, sum)
    
    // 2. 使用goto语句实现循环遍历输出1到10的数
    i := 1
loop:
    fmt.Print(i, &quot; &quot;)
    i++
    if i &lt;= 10 {
        goto loop
    }
    fmt.Println()
    
    // 3. 实现一个简单的计算器，能够进行加减乘除操作
    var op byte
    var operand1, operand2 float64
    fmt.Print(&quot;Please enter the operator(+,-,*,/): &quot;)
    fmt.Scanf(&quot;%c&quot;, &amp;op)
    fmt.Print(&quot;Please enter operand1: &quot;)
    fmt.Scanf(&quot;%f&quot;, &amp;operand1)
    fmt.Print(&quot;Please enter operand2: &quot;)
    fmt.Scanf(&quot;%f&quot;, &amp;operand2)
    switch op {
    case '+':
        fmt.Printf(&quot;%v + %v = %v\n&quot;, operand1, operand2, operand1+operand2)
    case '-':
        fmt.Printf(&quot;%v - %v = %v\n&quot;, operand1, operand2, operand1-operand2)
    case '*':
        fmt.Printf(&quot;%v * %v = %v\n&quot;, operand1, operand2, operand1*operand2)
    case '/':
        fmt.Printf(&quot;%v / %v = %v\n&quot;, operand1, operand2, operand1/operand2)
    default:
        fmt.Println(&quot;Invalid operator&quot;)
    }
    
    // 4. 输入一组字符串，去掉其中的重复字符，并以逆序输出
    s := &quot;Hello, World!&quot;
    m := make(map[rune]bool)
    var result string
    for _, ch := range s {
        if !m[ch] {
            m[ch] = true
            result += string(ch)
        }
    }
    for i := len(result)-1; i &gt;= 0; i-- {
        fmt.Print(string(result[i]))
    }
    fmt.Println()
    
    // 5. 输出100以内的所有斐波那契数列第二个数字为2的倍数的数列项
    a, b := 0, 1
    for i := 0; i &lt; 20; i++ {
        if b % 2 == 0 {
            fmt.Print(b, &quot; &quot;)
        }
        a, b = b, a+b
    }
    fmt.Println()
}
</code></pre>

<p><strong>Day 4</strong></p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    // 1. 将字符串转换成整数，并判断是否转换成功
    s := &quot;12345&quot;
    num := 0
    hasError := false
    for _, ch := range s {
        if ch &gt;= '0' &amp;&amp; ch &lt;= '9' {
            num = num*10 + int(ch-'0')
        } else {
            hasError = true
            break
        }
    }
    if hasError {
        fmt.Println(&quot;Invalid string&quot;)
    } else {
        fmt.Println(&quot;The integer is&quot;, num)
    }
    
    // 2. 实现一个简单的登录系统，并保存用户名和密码到文件中
    m := make(map[string]string)
    m[&quot;user1&quot;] = &quot;password1&quot;
    m[&quot;user2&quot;] = &quot;password2&quot;
    m[&quot;user3&quot;] = &quot;password3&quot;
    fmt.Print(&quot;Please enter your username: &quot;)
    var username string
    fmt.Scanf(&quot;%s&quot;, &amp;username)
    fmt.Print(&quot;Please enter your password: &quot;)
    var password string
    fmt.Scanf(&quot;%s&quot;, &amp;password)
    if m[username] == password {
        fmt.Printf(&quot;Welcome %s!\n&quot;, username)
    } else {
        fmt.Println(&quot;Invalid username or password!&quot;)
    }
    
    // 3. 判断一个数是否是回文数字
    num := 12321
    n, x := 0, num
    for x &gt; 0 {
        n = n*10 + x%10
        x /= 10
    }
    if num == n {
        fmt.Printf(&quot;%d is a palindrome number\n&quot;, num)
    } else {
        fmt.Printf(&quot;%d is not a palindrome number\n&quot;, num)
    }
    
    // 4. 输出1000以内的所有阶乘数列的末尾是0的项
    for i := 1; i &lt;= 1000; i++ {
        f := 1
        for j := 1; j &lt;= i; j++ {
            f *= j
        }
        if f % 10 == 0 {
            fmt.Print(i, &quot; &quot;)
        }
    }
    fmt.Println()
    
    // 5. 求出10以内的所有质数的和
    sum := 0
    for i := 2; i &lt;= 10; i++ {
        isPrime := true
        for j := 2; j &lt; i; j++ {
            if i % j == 0 {
                isPrime = false
                break
            }
        }
        if isPrime {
            sum += i
        }
    }
    fmt.Println(&quot;The sum of prime numbers is&quot;, sum)
}
</code></pre>

<p><strong>Day 5</strong></p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    // 1. 使用数组保存一组数据，并进行排序
    arr := [7]int{5, 8, 1, 3, 9, 2, 6}
    for i := 0; i &lt; len(arr)-1; i++ {
        for j := 0; j &lt; len(arr)-1-i; j++ {
            if arr[j] &gt; arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
    fmt.Println(arr)
    
    // 2. 按照给定的顺序反转数组
    a := [...]int{1, 2, 3, 4, 5, 6, 7, 8, 9}
    order := [...]int{8, 7, 6, 5, 4, 3, 2, 1, 0}
    for i, j := 0, len(a)-1; i &lt; j; i, j = i+1, j-1 {
        a[i], a[j] = a[j], a[i]
    }
    for i := 0; i &lt; len(a); i++ {
        fmt.Print(a[order[i]], &quot; &quot;)
    }
    fmt.Println()
    
    // 3. 实现一个简单的栈结构
    stack := []int{}
    stack = append(stack, 1)
    stack = append(stack, 2)
    stack = append(stack, 3)
    top := len(stack)-1
    fmt.Println(&quot;The top of stack is&quot;, stack[top])
    stack = stack[:top]
    top = len(stack)-1
    fmt.Println(&quot;The top of stack is&quot;, stack[top])
    
    // 4. 实现一个简单的队列结构
    queue := []int{}
    queue = append(queue, 1)
    queue = append(queue, 2)
    queue = append(queue, 3)
    front, rear := 0, len(queue)
    fmt.Println(&quot;The front of queue is&quot;, queue[front])
    queue = queue[1:]
    front, rear = front+1, len(queue)
    fmt.Println(&quot;The front of queue is&quot;, queue[front])
    
    // 5. 打印杨辉三角
    n := 10
    arr := make([][]int, n)
    for i := 0; i &lt; n; i++ {
        arr[i] = make([]int, i+1)
        for j := 0; j &lt;= i; j++ {
            if j == 0 || j == i {
                arr[i][j] = 1
            } else {
                arr[i][j] = arr[i-1][j-1] + arr[i-1][j]
            }
            fmt.Print(arr[i][j], &quot; &quot;)
        }
        fmt.Println()
    }
}
</code></pre>

<p><strong>Day 6</strong></p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    // 1. 判断一个字符串是否是回文字符串
    s := &quot;racecar&quot;
    for i := 0; i &lt; len(s)/2; i++ {
        if s[i] != s[len(s)-i-1] {
            fmt.Println(&quot;Not a palindrome string&quot;)
            break
        } else if i == len(s)/2-1 {
            fmt.Println(&quot;A palindrome string&quot;)
        }
    }
    
    // 2. 输出10以内的斐波那契数列中，最靠近100的数列项
    a, b := 0, 1
    num := 0
    for i := 0; i &lt; 10; i++ {
        if b &gt; 100 {
            break
        }
        num = b
        a, b = b, a+b
    }
    fmt.Printf(&quot;The nearest Fibonacci number to 100 is %d\n&quot;, num)
    
    // 3. 输出100以内的所有偶数和素数
    for i := 2; i &lt;= 100; i++ {
        if i % 2 == 0 {
            fmt.Print(i, &quot; &quot;)
        }
    }
    fmt.Println()
    for i := 2; i &lt;= 100; i++ {
        isPrime := true
        for j := 2; j &lt; i; j++ {
            if i % j == 0 {
                isPrime = false
                break
            }
        }
        if isPrime {
            fmt.Print(i, &quot; &quot;)
        }
    }
    fmt.Println()
    
    // 4. 实现一个简单的二叉树结构
    type Node struct {
        value int
        left *Node
        right *Node
    }
    root := &amp;Node{value:1, left:nil, right:nil}
    root.left = &amp;Node{value:2, left:nil, right:nil}
    root.right = &amp;Node{value:3, left:nil, right:nil}
    root.left.left = &amp;Node{value:4, left:nil, right:nil}
    root.left.right = &amp;Node{value:5, left:nil, right:nil}
    root.right.left = &amp;Node{value:6, left:nil, right:nil}
    root.right.right = &amp;Node{value:7, left:nil, right:nil}
    
    // 5. 实现一个简单的图结构
    type Graph struct {
        nodes []*Node
        edges map[Node][]*Node
    }
    graph := &amp;Graph{
        nodes:[]*Node{},
        edges:map[Node][]*Node{},
    }
    node1 := &amp;Node{value:1, left:nil, right:nil}
    node2 := &amp;Node{value:2, left:nil, right:nil}
    node3 := &amp;Node{value:3, left:nil, right:nil}
    graph.nodes = append(graph.nodes, node1)
    graph.nodes = append(graph.nodes, node2)
    graph.nodes = append(graph.nodes, node3)
    graph.edges[*node1] = []*Node{node2, node3}
    graph.edges[*node2] = []*Node{node3}
}
</code></pre>

<p>以上代码仅供参考，如有错误或不妥之处，欢迎指正。同时也建议读者在编写代码时，先尝试自己思考，多动手实践。</p>
 </body>
</html>